# interpreter for shell commands (needs to be POSIX compatible)
set shell zsh

# set previewer
set previewer ~/.config/lf/scope


# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.

# Do as explained here: https://github.com/gokcehan/lf/wiki/Tips#split-words-by-default-in-zsh
set shellopts '-eu:--shwordsplit'


# set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. 'filesep' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"
set filesep "\n"  # default already

# leave some space at the top and the bottom of the screen
set scrolloff 10

#set colors&icons
set color256
set icons

# use enter for shell commands
map <enter> shell

# execute current file (must be executable)
map x $$f
map X !$f

#adjust coloumn width to terminal
%{{
    w=$(tput cols)
    if [ $w -le 80 ]; then
        lf -remote "send $id set ratios 1:2"
    elif [ $w -le 160 ]; then
        lf -remote "send $id set ratios 1:2:3"
    else
        lf -remote "send $id set ratios 1:2:3:5"
    fi
}}

#reload
map <c-r> reload

#Clean Latex Compilation
cmd cleanlatex ${{
	latexcompile $fx &&
	notify-send "File(s) compiled."
}}
map L cleanlatex

#MOVE files
cmd moveto ${{
	set -f
	clear; echo "Move to where?"
	dest="$(cut -d'	' -f2- ~/.config/directories | fzf)" &&
	eval mv -iv $fx $dest &&
	notify-send "File(s) moved." "File(s) moved to $dest."
}}

#COPY files
cmd copyto ${{
	set -f
	clear; echo "Copy to where?"
	dest="$(cut -d'	' -f2- ~/.config/directories | fzf)" &&
	eval cp -ivr $fx $dest &&
	notify-send "File(s) copied." "File(s) copies to $dest."
}}
map C copyto
map M moveto

#fzf integration
cmd fzf_jump ${{
   res="$(find . -maxdepth 3 | fzf --reverse --header='Jump to location+2subdir')"
   if [ -f "$res" ]; then
     cmd="select"
   elif [ -d "$res" ]; then
     cmd="cd"                                                       
   fi
lf -remote "send $id $cmd \"$res\""
}}
map <c-f> :fzf_jump

map c $lf -remote "send $id cd $(cut -d'	' -f2 ~/.config/directories | fzf)"

# dedicated keys for file opener actions
map o &mimeopen "$f"
map O $mimeopen --ask "$f"

# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.
cmd open ${{

    case $(file --mime-type $f -b) in
        text/*) $EDITOR $fx;;
	image/vnd.djvu) setsid zathura $fx >/dev/null 2>&1 & ;;
	image/x-xcf|image/svg+xml) setsid gimp $f >/dev/null 2>&1 & ;;
        image/*) rotdir $f | setsid sxiv -aio 2>/dev/null | lf-select & ;;
	audio/*) mpv --input-ipc-server=/tmp/mpvsoc$(date +%%s) $f ;;
	video/*) setsid mpv --input-ipc-server=/tmp/mpvsoc$(date +%%s) $f -quiet >/dev/null 2>&1 & ;;
        application/pdf) setsid zathura $fx >/dev/null 2>&1 & ;;
        *) for f in $fx; do setsid $OPENER $f >/dev/null 2> /dev/null & done;;
    esac
}}



# define a custom 'rename' command without prompt for overwrite
 cmd rename %[ -e $1 ] && printf "file exists" || mv $f $1
# Unmap the default binding
map r
# Rename the file with a completely different name
map rc push :rename<space>
# Edit the current filename
map ra ${{
	# get 'basename' of the selection
	filename="${f##*/}"
	# quote it so we won't deal with quotes in the lf -remote command
	filename="$(printf '%q' '$filename')"
	filename="${filename// /<space>}"
	lf -remote "send $id push :rename<space>$filename"
}}
# Edit filename before the extension
map re ${{
	# get 'basename' of the selection
	filename="${f##*/}"
	# quote it so we won't deal with quotes in the lf -remote command
	filename="$(printf '%q' '$filename')"
	filename="${filename// /<space>}"
	lf -remote "send $id push :rename<space>$filename<a-b><c-b>"
}}



# move current file or selected files to trash folder
# (also see 'man mv' for backup/overwrite options)
cmd trash %set -f; mv $fx ~/.trash

cmd delete ${{
     set -f
     printf "$fx\n"
     printf "delete?[y/n]"
     read ans
     [ $ans = "y" ] && rm -rf $fx
}}

# use '<delete>' key for either 'trash' or 'delete' command
map <bs2> set hidden!
map <delete> delete


# Add delete with sudo command
#cmd Delete !{{
	#echo $fs | xargs -d$'\n' sudo rm -r
#}}
# Add paste with sudo command
cmd SudoPaste !{{
	lf -remote 'load' | while read file; do
		if [ ! -n "${mode+1}" ]; then
			mode="$file"
			continue
		fi
		files+=("$file")
	done
	if [[ "$mode" == copy ]]; then
		sudo cp -Rgi $files .
	elif [[ "$mode" == move ]]; then
		sudo mv -gi $files .
	fi
	# get 'basename' of the selection
	filename="${files[1]##*/}"
	# quote it so we won't deal with quotes in the lf -remote command
	filename="$(printf '%q' '$filename')"
	# need to reload before selecting
	lf -remote "send $id reload"
	lf -remote "send $id select $filename"
}}
# paste and select the file pasted
cmd Paste %{{
	lf -remote 'load' | while read file; do
		if [ ! -n "${mode+1}" ]; then
			mode="$file"
			continue
		fi
		if [ -f "${file}" ]; then
			# get 'basename' of the selection
			filename="${file##*/}"
			# quote it so we won't deal with quotes in the lf -remote command
			filename="$(printf '%q' '$filename')"
			break
		fi
	done
	lf -remote "send $id paste"
	lf -remote "send $id select $filename"
#}}
#map p Paste




# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;
    esac
}}

# compress current file or selected files with tar and gunzip
cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd zip ${{
    set -f
    mkdir $1
    cp -r $fx $1
    zip -r $1.zip $1
    rm -rf $1
}}

#mpv
cmd mpv_playlist_dir ${{
	set -f
	mpv $fx
}}
map P mpv_playlist_dir

#set by most recent:
map t :set sortby time; set info time; set reverse!

# better asynchronious search
map / $lf -remote "send $id select $(printf '%q' $(all_files=(./*(ND)); printf '%s\n' ${all_files[@]} | fzf))"

set drawbox on
set globsearch on

map U !du -sh      # waiting shell command for Usage

#extract and compress
map E extract
